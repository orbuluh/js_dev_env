#!/bin/bash

## From [random search](https://github.com/borestad/dotjitsu/blob/fff84c9e4f39acd719ebc92082eecf8ddaf8e6ef/.env%24#L38)

export FZF_TMUX_HEIGHT='90%'
export FZF_DEFAULT_COMMAND='fd -tf -c always'

export _FZF_DEFAULT_OPTS_NO_PREVIEW='--ansi --height 90% --border --layout=reverse --inline-info --pointer=❯'
export _FZF_DEFAULT_OPTS_PREVIEW="--ansi --bind 'ctrl-j:ignore,ctrl-k:ignore' --ansi --preview-window 'right:60%' --preview 'bat --color=always --style=header,grid --line-range :300 {}'"
export FZF_DEFAULT_OPTS="$_FZF_DEFAULT_OPTS_NO_PREVIEW --color=hl:#eb4034,hl+:#ff0000 --exact"

# ctrl+t
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
export FZF_CTRL_T_OPTS="$_FZF_DEFAULT_OPTS_PREVIEW"

# ctrl+r
export FZF_CTRL_R_OPTS=""

# alt+c
export FZF_ALT_C_COMMAND="fd -td -c always --base-directory ."

## Mainly from [fzf example](https://github.com/junegunn/fzf/wiki/examples)

#------------------------------------------------------------

# Run command/application and choose paths/files with fzf.
# Always return control of the terminal to user (e.g. when opening GUIs).
# The full command that was used will appear in your history just like any
# other (N.B. to achieve this I write the shell's active history to
# ~/.bash_history)
#
# Usage:
# f cd [OPTION]... (hit enter, choose path)
# f cat [OPTION]... (hit enter, choose files)
# f vim [OPTION]... (hit enter, choose files)
# f vlc [OPTION]... (hit enter, choose files)

f() {
  # Store the program
  program="$1"

  # Remove first argument off the list
  shift

  # Store option flags with separating spaces, or just set as single space
  options="$@"
  if [ -z "${options}" ]; then
    options=" "
  else
    options=" $options "
  fi

  # Store the arguments from fzf
  arguments="$(fzf --multi)"

  # If no arguments passed (e.g. if Esc pressed), return to terminal
  if [ -z "${arguments}" ]; then
    return 1
  fi

  # We want the command to show up in our bash history, so write the shell's
  # active history to ~/.bash_history. Then we'll also add the command from
  # fzf, then we'll load it all back into the shell's active history
  history -w

  # ADD A REPEATABLE COMMAND TO THE BASH HISTORY ############################
  # Store the arguments in a temporary file for sanitising before being
  # entered into bash history
  : >/tmp/fzf_tmp
  for file in "${arguments[@]}"; do
    echo "$file" >>/tmp/fzf_tmp
  done

  # Put all input arguments on one line and sanitise the command by putting
  # single quotes around each argument, also first put an extra single quote
  # next to any pre-existing single quotes in the raw argument
  sed -i "s/'/''/g; s/.*/'&'/g; s/\n//g" /tmp/fzf_tmp

  # If the program is on the GUI list, add a '&' to the command history
  if [[ "$program" =~ ^(nautilus|zathura|evince|vlc|eog|kolourpaint)$ ]]; then
    sed -i '${s/$/ \&/}' /tmp/fzf_tmp
  fi

  # Grab the sanitised arguments
  arguments="$(cat /tmp/fzf_tmp)"

  # Add the command with the sanitised arguments to our .bash_history
  echo $program$options$arguments >>~/.bash_history

  # Reload the ~/.bash_history into the shell's active history
  history -r

  # EXECUTE THE LAST COMMAND IN ~/.bash_history #############################
  fc -s -1

  # Clean up temporary variables
  rm /tmp/fzf_tmp
}

# fcd - cd to selected directory
# ex
# fcd        # Find and select a directory from the current directory.
# fcd ~/docs # Find and select a directory starting from ~/docs.
fcd() {
  # -path '*/\.*' -prune: Ignores hidden directories (like .git, .config) to keep the list clean.
  local dir
  dir=$(find ${1:-.} -path '*/\.*' -prune \
    -o -type d -print 2>/dev/null | fzf +m) &&
    cd "$dir"
}

# fda - including hidden directories
fda() {
  local dir
  dir=$(find ${1:-.} -type d 2>/dev/null | fzf +m) && cd "$dir"
}

# cf - fuzzy cd from anywhere
# ex: cf word1 word2 ... (even part of a file name)
# if word is file, cd to its corresponding directory
cf() {
  local file

  # grep -z -vE '~$' filters out files ending with ~ (typically backup files) from the results, using null (-z) as the separator.
  # -0: Exits with no selection if there’s no match.
  # -1: Exits immediately if there’s only one match.
  file="$(locate -Ai -0 $@ | grep -z -vE '~$' | fzf --read0 -0 -1)"

  if [[ -n $file ]]; then
    if [[ -d $file ]]; then
      cd -- $file
    else
      # Goes to the directory containing the file by extracting the directory path from file.
      cd -- ${file:h}
    fi
  fi
}

# Searching file contents
# find-in-file - usage: fif <searchTerm> or fif "string with spaces" or fif "regex"
fif() {
  if [ "$#" -le 0 ]; then
    echo "Please provide a search term!"
    return 1
  fi

  local file
  # Run ripgrep-all (rga) to search for the term and list files with matches
  file="$(rga --max-count=1 --ignore-case --files-with-matches --no-messages "$*" |
    fzf-tmux +m --preview="rga --ignore-case --pretty --context 5 '$*' {}")"

  # Check if a file was selected and that it exists
  if [[ -n "$file" && -f "$file" ]]; then
    # Determine the file type
    file_type=$(file --brief "$file")

    # Check if the file is a text file
    if [[ "$file_type" == *text* ]]; then
      echo "Opening $file in vim"
      vim "$file"
    else
      echo "$file is a binary file ($file_type) and will not be opened with vim."
    fi
  else
    return 1
  fi
}

# fkill - kill processes - list only the ones you can kill. Modified the earlier script.
fkill() {
  local pid
  if [ "$UID" != "0" ]; then
    pid=$(ps -f -u $UID | sed 1d | fzf -m | awk '{print $2}')
  else
    pid=$(ps -ef | sed 1d | fzf -m | awk '{print $2}')
  fi

  if [ "x$pid" != "x" ]; then
    echo $pid | xargs kill -${1:-9}
  fi
}

# fco - checkout git branch/tag, with a preview showing the commits between the tag/branch and HEAD
fco() {
  local tags branches target
  branches=$(
    git --no-pager branch --all \
      --format="%(if)%(HEAD)%(then)%(else)%(if:equals=HEAD)%(refname:strip=3)%(then)%(else)%1B[0;34;1mbranch%09%1B[m%(refname:short)%(end)%(end)" |
      sed '/^$/d'
  ) || return
  tags=$(
    git --no-pager tag | awk '{print "\x1b[35;1mtag\x1b[m\t" $1}'
  ) || return
  target=$(
    (
      echo "$branches"
      echo "$tags"
    ) |
      fzf --no-hscroll --no-multi -n 2 \
        --ansi --preview="git --no-pager log -150 --pretty=format:%s '..{2}'"
  ) || return
  git checkout $(awk '{print $2}' <<<"$target")
}
