#!/bin/bash

## Mainly from [fzf example](https://github.com/junegunn/fzf/wiki/examples)

#------------------------------------------------------------

# Run command/application and choose paths/files with fzf.
# Always return control of the terminal to user (e.g. when opening GUIs).
# The full command that was used will appear in your history just like any
# other (N.B. to achieve this I write the shell's active history to
# ~/.bash_history)
#
# Usage:
# f cd [OPTION]... (hit enter, choose path)
# f cat [OPTION]... (hit enter, choose files)
# f vim [OPTION]... (hit enter, choose files)
# f vlc [OPTION]... (hit enter, choose files)

f() {
  # Store the program
  program="$1"

  # Remove first argument off the list
  shift

  # Store option flags with separating spaces, or just set as single space
  options="$@"
  if [ -z "${options}" ]; then
    options=" "
  else
    options=" $options "
  fi

  # Store the arguments from fzf
  arguments="$(fzf --multi)"

  # If no arguments passed (e.g. if Esc pressed), return to terminal
  if [ -z "${arguments}" ]; then
    return 1
  fi

  # We want the command to show up in our bash history, so write the shell's
  # active history to ~/.bash_history. Then we'll also add the command from
  # fzf, then we'll load it all back into the shell's active history
  history -w

  # ADD A REPEATABLE COMMAND TO THE BASH HISTORY ############################
  # Store the arguments in a temporary file for sanitising before being
  # entered into bash history
  : >/tmp/fzf_tmp
  for file in "${arguments[@]}"; do
    echo "$file" >>/tmp/fzf_tmp
  done

  # Put all input arguments on one line and sanitise the command by putting
  # single quotes around each argument, also first put an extra single quote
  # next to any pre-existing single quotes in the raw argument
  sed -i "s/'/''/g; s/.*/'&'/g; s/\n//g" /tmp/fzf_tmp

  # If the program is on the GUI list, add a '&' to the command history
  if [[ "$program" =~ ^(nautilus|zathura|evince|vlc|eog|kolourpaint)$ ]]; then
    sed -i '${s/$/ \&/}' /tmp/fzf_tmp
  fi

  # Grab the sanitised arguments
  arguments="$(cat /tmp/fzf_tmp)"

  # Add the command with the sanitised arguments to our .bash_history
  echo $program$options$arguments >>~/.bash_history

  # Reload the ~/.bash_history into the shell's active history
  history -r

  # EXECUTE THE LAST COMMAND IN ~/.bash_history #############################
  fc -s -1

  # Clean up temporary variables
  rm /tmp/fzf_tmp
}

# fd - cd to selected directory
# ex
# fd        # Find and select a directory from the current directory.
# fd ~/docs # Find and select a directory starting from ~/docs.
fd() {
  # -path '*/\.*' -prune: Ignores hidden directories (like .git, .config) to keep the list clean.
  local dir
  dir=$(find ${1:-.} -path '*/\.*' -prune \
    -o -type d -print 2>/dev/null | fzf +m) &&
    cd "$dir"
}

# fda - including hidden directories
fda() {
  local dir
  dir=$(find ${1:-.} -type d 2>/dev/null | fzf +m) && cd "$dir"
}

# cf - fuzzy cd from anywhere
# ex: cf word1 word2 ... (even part of a file name)
# if word is file, cd to its corresponding directory
cf() {
  local file

  # grep -z -vE '~$' filters out files ending with ~ (typically backup files) from the results, using null (-z) as the separator.
  # -0: Exits with no selection if there’s no match.
  # -1: Exits immediately if there’s only one match.
  file="$(locate -Ai -0 $@ | grep -z -vE '~$' | fzf --read0 -0 -1)"

  if [[ -n $file ]]; then
    if [[ -d $file ]]; then
      cd -- $file
    else
      # Goes to the directory containing the file by extracting the directory path from file.
      cd -- ${file:h}
    fi
  fi
}

# Searching file contents
# find-in-file - usage: fif <searchTerm> or fif "string with spaces" or fif "regex"
# -------
# alternative using ripgrep-all (rga) combined with fzf-tmux preview
# This requires ripgrep-all (rga) installed: https://github.com/phiresky/ripgrep-all
# This implementation below makes use of "open" on macOS, which can be replaced by other commands if needed.
# allows to search in PDFs, E-Books, Office documents, zip, tar.gz, etc. (see https://github.com/phiresky/ripgrep-all)
fif() {
  if [ ! "$#" -gt 0 ]; then
    echo "Need a string to search for!"
    return 1
  fi
  local file
  file="$(rga --max-count=1 --ignore-case --files-with-matches --no-messages "$*" | fzf-tmux +m --preview="rga --ignore-case --pretty --context 10 '"$*"' {}")" && echo "opening $file" && open "$file" || return 1
}

# fkill - kill processes - list only the ones you can kill. Modified the earlier script.
fkill() {
  local pid
  if [ "$UID" != "0" ]; then
    pid=$(ps -f -u $UID | sed 1d | fzf -m | awk '{print $2}')
  else
    pid=$(ps -ef | sed 1d | fzf -m | awk '{print $2}')
  fi

  if [ "x$pid" != "x" ]; then
    echo $pid | xargs kill -${1:-9}
  fi
}

# fco - checkout git branch/tag, with a preview showing the commits between the tag/branch and HEAD
fco() {
  local tags branches target
  branches=$(
    git --no-pager branch --all \
      --format="%(if)%(HEAD)%(then)%(else)%(if:equals=HEAD)%(refname:strip=3)%(then)%(else)%1B[0;34;1mbranch%09%1B[m%(refname:short)%(end)%(end)" |
      sed '/^$/d'
  ) || return
  tags=$(
    git --no-pager tag | awk '{print "\x1b[35;1mtag\x1b[m\t" $1}'
  ) || return
  target=$(
    (
      echo "$branches"
      echo "$tags"
    ) |
      fzf --no-hscroll --no-multi -n 2 \
        --ansi --preview="git --no-pager log -150 --pretty=format:%s '..{2}'"
  ) || return
  git checkout $(awk '{print $2}' <<<"$target")
}
